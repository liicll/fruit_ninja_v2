<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç½‘é¡µç‰ˆæ°´æœåˆ‡åˆ‡ä¹</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* æœ¨å¤´èœæ¿èƒŒæ™¯ */
            background-color: #8b5a2b;
            background-image: 
                radial-gradient(circle, rgba(0,0,0,0.1), rgba(0,0,0,0.6)),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 12px),
                linear-gradient(to bottom, #a0522d, #5c3317);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* å…³é”®ï¼šç¦æ­¢ç§»åŠ¨ç«¯é»˜è®¤çš„ç¼©æ”¾å’Œæ»šåŠ¨ */
            -webkit-user-select: none; /* ç¦æ­¢é€‰ä¸­æ–‡æœ¬ */
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI è¦†ç›–å±‚ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 5;
        }

        .score-board {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: flex;
            gap: 20px;
            margin-top: 30px; /* ç»™é¡¶éƒ¨æ°´å°ç•™å‡ºä½ç½® */
        }

        .lives {
            color: #ff4757;
            font-size: 24px;
        }

        /* èœå•å±å¹• */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 40px;
            margin-bottom: 10px;
            color: #ffd700;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        p {
            font-size: 16px;
            color: #ddd;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 22px;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
            touch-action: manipulation; /* ä¼˜åŒ–ç‚¹å‡» */
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        #final-score {
            font-size: 60px;
            font-weight: bold;
            color: #2ed573;
            margin: 20px 0;
        }

        /* æ°´å°æ ·å¼ (å±…ä¸­ç½®é¡¶) */
        .watermark {
            position: absolute;
            top: 15px; 
            left: 0;
            width: 100%; 
            text-align: center; 
            color: rgba(255, 255, 255, 0.3); /* åŠé€æ˜ç™½è‰² */
            font-size: 16px;
            font-weight: bold;
            pointer-events: none; 
            z-index: 100;
            user-select: none;
            font-family: "Microsoft YaHei", sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- æ°´å° -->
    <div class="watermark">æ‰¿é¾™æ¸¸æˆåˆ¶ä½œï¼Œç›—ç‰ˆå¿…ç©¶</div>

    <!-- æ¸¸æˆ UI -->
    <div class="ui-layer">
        <div class="score-board">
            <span id="score-display">åˆ†æ•°: 0</span>
            <span id="best-score-display">æœ€é«˜: 0</span>
        </div>
        <div class="lives" id="lives-display">â¤ï¸â¤ï¸â¤ï¸</div>
    </div>

    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <h1>ğŸ‰ æ°´æœåˆ‡åˆ‡ä¹ ğŸŒ</h1>
        <p>æ‰‹æŒ‡åˆ’è¿‡å±å¹•åˆ‡å¼€æ°´æœ<br>ä¸è¦åˆ‡åˆ°é»‘è‰²ç‚¸å¼¹ï¼</p>
        <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
    </div>

    <!-- ç»“æŸç•Œé¢ -->
    <div id="game-over-screen" class="hidden">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p>æœ¬å±€å¾—åˆ†</p>
        <div id="final-score">0</div>
        <button id="restart-btn">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    // --- æ¸¸æˆé…ç½®ä¸å…¨å±€å˜é‡ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–æ€§èƒ½
    
    // UI å…ƒç´ 
    const scoreEl = document.getElementById('score-display');
    const bestScoreEl = document.getElementById('best-score-display');
    const livesEl = document.getElementById('lives-display');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    // æ¸¸æˆçŠ¶æ€
    let gameState = 'MENU';
    let score = 0;
    let lives = 3;
    let gameTime = 0;
    
    // å®ä½“æ•°ç»„
    let fruits = [];
    let particles = [];
    let trailPoints = [];

    // æ°´æœå®šä¹‰ (é€‚é…å®‰å“å­—ä½“æ˜¾ç¤º)
    const FRUIT_TYPES = [
        { emoji: 'ğŸ‰', color: '#ff6b6b', points: 10, radius: 50 },
        { emoji: 'ğŸŒ', color: '#ffeaa7', points: 15, radius: 45 },
        { emoji: 'ğŸ', color: '#ff4757', points: 10, radius: 45 },
        { emoji: 'ğŸ', color: '#f9ca24', points: 20, radius: 50 },
        { emoji: 'ğŸŠ', color: '#ff9f43', points: 10, radius: 45 },
        { emoji: 'ğŸ¥¥', color: '#dfe4ea', points: 25, radius: 48 },
        { emoji: 'ğŸ¥', color: '#badc58', points: 15, radius: 45 }
    ];

    const BOMB_TYPE = { emoji: 'ğŸ’£', color: '#2f3542', radius: 50 };

    // è¾“å…¥è¿½è¸ª
    const input = { x: 0, y: 0, isDown: false };

    // --- éŸ³é¢‘ç³»ç»Ÿ (å®‰å…¨æ¨¡å¼) ---
    let audioCtx = null;
    let audioEnabled = true;

    function initAudio() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) {
                console.log("æµè§ˆå™¨ä¸æ”¯æŒ Web Audio API");
                audioEnabled = false;
                return;
            }
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        } catch (e) {
            console.warn("éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥ï¼Œåˆ‡æ¢åˆ°é™éŸ³æ¨¡å¼", e);
            audioEnabled = false;
        }
    }

    function playSound(type) {
        if (!audioEnabled || !audioCtx) return;

        try {
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            if (type === 'slice') {
                // åˆ‡æ°´æœå£°éŸ³
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(1000, t);
                
                noise.connect(filter);
                filter.connect(gain);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                gain.connect(audioCtx.destination);
                noise.start();
            } else if (type === 'throw') {
                // æŠ›å‡ºå£°éŸ³
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
                
                gain.gain.setValueAtTime(0.05, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.15);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(t + 0.2);
            }
        } catch (e) {
            // å¿½ç•¥æ’­æ”¾é”™è¯¯
        }
    }

    // --- åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬ ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function getEventPos(e) {
        if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
    }

    function handleInputStart(e) {
        if (e.type === 'mousedown' && e.button !== 0) return;
        input.isDown = true;
        const pos = getEventPos(e);
        input.x = pos.x;
        input.y = pos.y;
        trailPoints = [];
    }

    function handleInputMove(e) {
        if (!input.isDown) return;
        e.preventDefault(); 
        const pos = getEventPos(e);
        input.x = pos.x;
        input.y = pos.y;
        addTrailPoint(input.x, input.y);
        checkCollisions(input.x, input.y);
    }

    function handleInputEnd(e) {
        input.isDown = false;
        trailPoints = [];
    }

    canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);

    canvas.addEventListener('touchstart', handleInputStart, {passive: false});
    canvas.addEventListener('touchmove', handleInputMove, {passive: false});
    window.addEventListener('touchend', handleInputEnd);

    startBtn.addEventListener('click', () => {
        initAudio(); 
        startGame();
    });
    restartBtn.addEventListener('click', startGame);

    let bestScore = localStorage.getItem('fruitNinjaBestScore') || 0;
    bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;

    // --- æ¸¸æˆç±» ---

    class Fruit {
        constructor() {
            this.reset();
        }

        reset() {
            const isBomb = Math.random() < Math.min(0.1 + (gameTime * 0.0001), 0.3);
            if (isBomb) {
                this.type = BOMB_TYPE;
                this.isBomb = true;
            } else {
                this.type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                this.isBomb = false;
            }

            const margin = 50;
            this.x = Math.random() * (canvas.width - margin * 2) + margin;
            this.y = canvas.height + 60;
            
            const direction = this.x > canvas.width / 2 ? -1 : 1;
            this.vx = (Math.random() * 2 + 1) * direction; 
            
            this.gravity = 0.12; 
            const targetHeight = canvas.height * (0.5 + Math.random() * 0.3);
            this.vy = -Math.sqrt(2 * this.gravity * targetHeight);
            
            this.rotation = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            this.active = true;
            this.sliced = false;

            if (gameState === 'PLAYING') playSound('throw');
        }

        update() {
            if (!this.active) return;
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.rotation += this.rotationSpeed;

            if (this.x < this.type.radius) {
                this.x = this.type.radius;
                this.vx *= -0.5;
            } else if (this.x > canvas.width - this.type.radius) {
                this.x = canvas.width - this.type.radius;
                this.vx *= -0.5;
            }

            if (this.y > canvas.height + 70) {
                this.active = false;
                if (!this.isBomb && !this.sliced && gameState === 'PLAYING') {
                    loseLife();
                }
            }
        }

        draw() {
            if (!this.active || this.sliced) return;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.font = "80px 'Noto Color Emoji', 'Apple Color Emoji', 'Segoe UI Emoji', Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.type.emoji, 0, 10); 
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, isText = false, text = '') {
            this.x = x;
            this.y = y;
            this.color = color;
            this.isText = isText;
            this.text = text;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.015;
            this.gravity = 0.15;
            this.size = Math.random() * 5 + 3;
            this.rotation = Math.random() * Math.PI;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.life -= this.decay;
            if (this.isText) this.rotation += 0.1;
        }

        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            if (this.isText) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = "60px 'Noto Color Emoji', 'Apple Color Emoji', Arial";
                ctx.fillText(this.text, 0, 0);
                ctx.restore();
            } else {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }
    }

    class FloatingText {
        constructor(x, y, text) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.life = 1.0;
            this.vy = -2;
        }
        update() { this.y += this.vy; this.life -= 0.02; }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = "#fff";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.font = "bold 40px Arial";
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- æ¸¸æˆå¾ªç¯ä¸é€»è¾‘ ---

    function startGame() {
        score = 0;
        lives = 3;
        gameTime = 0;
        fruits = [];
        particles = [];
        trailPoints = [];
        updateUI();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        gameState = 'PLAYING';
        spawnLoop();
        requestAnimationFrame(gameLoop);
    }

    function spawnLoop() {
        if (gameState !== 'PLAYING') return;
        const baseInterval = 1500;
        const interval = Math.max(600, baseInterval - (gameTime * 0.2));
        
        fruits.push(new Fruit());
        if (Math.random() < 0.2 && gameTime > 500) fruits.push(new Fruit());

        fruits = fruits.filter(f => f.active);
        setTimeout(spawnLoop, interval);
    }

    function addTrailPoint(x, y) {
        trailPoints.push({ x, y, life: 1.0 });
    }

    function updateTrail() {
        for (let i = trailPoints.length - 1; i >= 0; i--) {
            trailPoints[i].life -= 0.15;
            if (trailPoints[i].life <= 0) trailPoints.splice(i, 1);
        }
    }

    function drawTrail() {
        if (trailPoints.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
        for (let i = 1; i < trailPoints.length; i++) {
            const p = trailPoints[i];
            ctx.strokeStyle = `rgba(255, 255, 255, ${p.life})`;
            ctx.lineWidth = p.life * 15;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    function checkCollisions(x, y) {
        if (trailPoints.length < 2) return; 
        fruits.forEach(fruit => {
            if (fruit.active && !fruit.sliced) {
                const dx = x - fruit.x;
                const dy = y - fruit.y;
                if (dx*dx + dy*dy < fruit.type.radius * fruit.type.radius * 1.5) {
                    sliceFruit(fruit);
                }
            }
        });
    }

    function sliceFruit(fruit) {
        fruit.sliced = true;
        playSound('slice');

        if (fruit.isBomb) {
            createExplosion(fruit.x, fruit.y);
            triggerGameOver();
        } else {
            score += fruit.type.points;
            updateUI();
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle(fruit.x, fruit.y, fruit.type.color));
            }
            particles.push(new FloatingText(fruit.x, fruit.y, `+${fruit.type.points}`));
            
            // æ®‹éª¸
            const p1 = new Particle(fruit.x, fruit.y, null, true, fruit.type.emoji);
            p1.vx = -4; p1.vy = -4;
            const p2 = new Particle(fruit.x, fruit.y, null, true, fruit.type.emoji);
            p2.vx = 4; p2.vy = -4;
            particles.push(p1, p2);
        }
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 30; i++) {
            particles.push(new Particle(x, y, '#ff0000'));
        }
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function loseLife() {
        lives--;
        updateUI();
        if (lives <= 0) triggerGameOver();
    }

    function updateUI() {
        scoreEl.innerText = `åˆ†æ•°: ${score}`;
        let hearts = '';
        for(let i=0; i<lives; i++) hearts += 'â¤ï¸';
        livesEl.innerText = hearts;
    }

    function triggerGameOver() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('fruitNinjaBestScore', bestScore);
            bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;
        }
        gameOverScreen.classList.remove('hidden');
    }

    function gameLoop() {
        if (gameState !== 'PLAYING' && particles.length === 0) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'PLAYING') {
            gameTime++;
            fruits.forEach(f => { f.update(); f.draw(); });
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        updateTrail();
        drawTrail();

        if (gameState === 'PLAYING' || particles.length > 0) {
            requestAnimationFrame(gameLoop);
        }
    }
</script>
</body>
</html>